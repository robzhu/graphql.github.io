<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>Validation | GraphQL</title><meta name="viewport" content="width=device-width"/><meta property="og:title" content="GraphQL | A data query language and runtime"/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql.org/"/><meta property="og:description" content="A data query language and runtime"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="/css/graphql.css"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL Team Blog"/><script type="text/javascript" src="//use.typekit.net/vqa1hcx.js"></script><script type="text/javascript">try{Typekit.load();}catch(e){}</script></head><body><div class="container"><div class="nav-main"><div class="wrap"><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="40" height="40"/>GraphQL</a><div class="nav-site-wrapper"><ul class="nav-site nav-site-internal"><li><a href="/docs/getting-started/" class="active">Docs</a></li><li><a href="/blog/" class="">Blog</a></li><li><a href="/help/" class="">Help</a></li><li><a href="/code/" class="">Code</a></li></ul><div class="algolia-search-wrapper"><input id="algolia-doc-search" type="text" placeholder="Search docs..."/></div><ul class="nav-site nav-site-external"><li><a href="http://facebook.github.io/graphql/" target="_blank" class="">Spec</a></li></ul></div></div></div><section class="content wrap documentationContent"><div class="nav-docs"><div class="nav-docs-section"><h3>Quick Start</h3><ul><li><a style="margin-left:0;" class="active" href="/docs/getting-started/">Getting Started</a></li><li><a style="margin-left:0;" class="active" href="/docs/videos/">Videos</a></li></ul></div><div class="nav-docs-section"><h3>Walkthrough</h3><ul><li><a style="margin-left:0;" class="active" href="/docs/intro/">Introduction</a></li><li><a style="margin-left:0;" class="active" href="/docs/typesystem/">Type System</a></li><li><a style="margin-left:0;" class="active" href="/docs/queries/">Queries</a></li><li><a style="margin-left:0;" class="active" href="/docs/validation/">Validation</a></li><li><a style="margin-left:0;" class="active" href="/docs/introspection/">Introspection</a></li></ul></div><div class="nav-docs-section"><h3>API Reference</h3><ul><li><a style="margin-left:0;" class="active" href="/docs/api-reference-graphql/">GraphQL</a></li><li><a style="margin-left:0;" class="active" href="/docs/api-reference-language/">Language</a></li><li><a style="margin-left:0;" class="active" href="/docs/api-reference-type-system/">Type System</a></li><li><a style="margin-left:0;" class="active" href="/docs/api-reference-validation/">Validation</a></li><li><a style="margin-left:0;" class="active" href="/docs/api-reference-execution/">Execution</a></li><li><a style="margin-left:0;" class="active" href="/docs/api-reference-errors/">Errors</a></li><li><a style="margin-left:0;" class="active" href="/docs/api-reference-utilities/">Utilities</a></li></ul></div></div><div class="inner-content"><h1>Validation</h1><div><p>By using the type system, it can be predetermined whether a GraphQL query
is valid or not. This allows servers and clients to effectively inform
developers when an invalid query has been created, without having to rely
on runtime checks.</p><p>For our Star Wars example, the file
<a href="https://github.com/graphql/graphql-js/blob/master/src/__tests__/starWarsValidation-test.js" target="_blank">starWarsValidation-test.js</a>
contains a number of queries demonstrating various invalidities, and is a test
file that can be run to exercise the reference implementation&#x27;s validator.</p><p>To start, let&#x27;s take a complex valid query. This is a nested query, similar to
an example from the previous section, but with the duplicated fields factored
out into a fragment:</p><div><div id="r101"><div class="miniGraphiQL" data-reactid=".1fql741g422" data-react-checksum="1558592596"><div class="query-editor" data-reactid=".1fql741g422.0"></div><div class="result-window" data-reactid=".1fql741g422.1"></div></div></div>

</div><p>And this query is valid. Let&#x27;s take a look at some invalid queries...</p><p>A fragment cannot refer to itself or create a cycle, as this could result in
an unbounded result! Here&#x27;s the same query above but without the explicit three
levels of nesting:</p><div><div id="r102"><div class="miniGraphiQL" data-reactid=".16giqhut59s" data-react-checksum="415448757"><div class="query-editor" data-reactid=".16giqhut59s.0"></div><div class="result-window" data-reactid=".16giqhut59s.1"></div></div></div>

</div><p>When we query for fields, we have to query for a field that exists on the
given type. So as <code>hero</code> returns a <code>Character</code>, we have to query for a field
on <code>Character</code>. That type does not have a <code>favoriteSpaceship</code> field, so this
query is invalid:</p><div><div id="r103"><div class="miniGraphiQL" data-reactid=".1knv3fewqiq" data-react-checksum="2029404135"><div class="query-editor" data-reactid=".1knv3fewqiq.0"></div><div class="result-window" data-reactid=".1knv3fewqiq.1"></div></div></div>

</div><p>Whenever we query for a field and it returns something other than a scalar
or an enum, we need to specify what data we want to get back from the field.
Hero returns a <code>Character</code>, and we&#x27;ve been requesting fields like <code>name</code> and
<code>appearsIn</code> on it; if we omit that, the query will not be valid:</p><div><div id="r104"><div class="miniGraphiQL" data-reactid=".lhudoq2fzi" data-react-checksum="-598458561"><div class="query-editor" data-reactid=".lhudoq2fzi.0"></div><div class="result-window" data-reactid=".lhudoq2fzi.1"></div></div></div>

</div><p>Similarly, if a field is a scalar, it doesn&#x27;t make sense to query for
additional fields on it, and doing so will make the query invalid:</p><div><div id="r105"><div class="miniGraphiQL" data-reactid=".1mxusbtky" data-react-checksum="582041167"><div class="query-editor" data-reactid=".1mxusbtky.0"></div><div class="result-window" data-reactid=".1mxusbtky.1"></div></div></div>

</div><p>Earlier, it was noted that a query can only query for fields on the type
in question; when we query for <code>hero</code> which returns a <code>Character</code>, we
can only query for fields that exist on <code>Character</code>. What happens if we
want to query for R2-D2s primary function, though?</p><div><div id="r106"><div class="miniGraphiQL" data-reactid=".1s5sswa8zyc" data-react-checksum="1599618966"><div class="query-editor" data-reactid=".1s5sswa8zyc.0"></div><div class="result-window" data-reactid=".1s5sswa8zyc.1"></div></div></div>

</div><p>That query is invalid, because <code>primaryFunction</code> is not a field on <code>Character</code>.
We want some way of indicating that we wish to fetch <code>primaryFunction</code> if the
<code>Character</code> is a <code>Droid</code>, and to ignore that field otherwise. We can use
the fragments we introduced earlier to do this. By setting up a fragment defined
on <code>Droid</code> and including it, we ensure that we only query for <code>primaryFunction</code>
where it is defined.</p><div><div id="r107"><div class="miniGraphiQL" data-reactid=".bjhc64x3p8" data-react-checksum="888552739"><div class="query-editor" data-reactid=".bjhc64x3p8.0"></div><div class="result-window" data-reactid=".bjhc64x3p8.1"></div></div></div>

</div><p>This query is valid, but it&#x27;s a bit verbose; named fragments were valuable
above when we used them multiple times, but we&#x27;re only using this one once.
Instead of using a named fragment, we can use an inline fragment; this
still allows us to indicate the type we are querying on, but without naming
a separate fragment:</p><div><div id="r108"><div class="miniGraphiQL" data-reactid=".1mxkrck2r9o" data-react-checksum="1287798606"><div class="query-editor" data-reactid=".1mxkrck2r9o.0"></div><div class="result-window" data-reactid=".1mxkrck2r9o.1"></div></div></div>

</div><p>This has just scratched the surface of the validation system; there
are a number of validation rules in place to ensure that a GraphQL query
is semantically meaningful. The specification goes into more detail about this
topic in the &quot;Validation&quot; section, and the
<a href="https://github.com/graphql/graphql-js/blob/master/src/validation" target="_blank">validation</a>
directory in GraphQL.js contains code implementing a
specification-compliant GraphQL validator.</p></div><div class="docs-prevnext"><a class="docs-next" href="/docs/introspection">Next →</a></div></div></section><footer class="wrap"><div class="right">©2016 Facebook Inc.</div></footer></div><div id="fb-root"></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
            !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
            docsearch({
              apiKey: 'd103541f3e6041148aade2e746ed4d61',
              indexName: 'graphql',
              inputSelector: '#algolia-doc-search'
            });
          </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
          </script><script src="//cdn.jsdelivr.net/react/0.13.3/react.js"></script><script src="index.html.1e0ba10063d7429f52f2.js"></script></body></html>